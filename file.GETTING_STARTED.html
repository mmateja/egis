<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: GETTING_STARTED
  
    &mdash; Documentation by YARD 0.9.25
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "GETTING_STARTED";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: GETTING_STARTED</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'>
<h1 id="label-GETTING+STARTED">GETTING STARTED</h1>

<h2 id="label-Configuration">Configuration</h2>

<p>Setup gem using the configuration block:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Egis.html" title="Egis (module)">Egis</a></span></span><span class='period'>.</span><span class='id identifier rubyid_configure'><span class='object_link'><a href="Egis.html#configure-class_method" title="Egis.configure (method)">configure</a></span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_config'>config</span><span class='op'>|</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_aws_region'>aws_region</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>AWS region</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_aws_access_key_id'>aws_access_key_id</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>AWS key ID</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_aws_secret_access_key'>aws_secret_access_key</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>AWS secret key</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_work_group'>work_group</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>egis-integration-testing</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
</code></pre>

<p>if you don&#39;t provide these values, <code>Egis</code> will use standard AWS client&#39;s config, looking for credentials in standard locations. For more info refer to: <a href="https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html">docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html</a></p>

<p>You can set <code>aws_profile</code> attribute to use specific profile from <code>~/.aws/credentials</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Egis.html" title="Egis (module)">Egis</a></span></span><span class='period'>.</span><span class='id identifier rubyid_configure'><span class='object_link'><a href="Egis.html#configure-class_method" title="Egis.configure (method)">configure</a></span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_config'>config</span><span class='op'>|</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_aws_profile'>aws_profile</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>my-credentials-profile</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
</code></pre>

<p><code>Egis</code> client is a class that provides you with the interface for schema manipulation and running queries</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_client'>client</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Egis.html" title="Egis (module)">Egis</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Egis/Client.html" title="Egis::Client (class)">Client</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="Egis/Client.html#initialize-instance_method" title="Egis::Client#initialize (method)">new</a></span></span>
</code></pre>

<h2 id="label-Creating+databases">Creating databases</h2>

<p>You can create and remove databases by using client&#39;s <code>database</code> factory method.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_database'>database</span> <span class='op'>=</span> <span class='id identifier rubyid_client'>client</span><span class='period'>.</span><span class='id identifier rubyid_database'>database</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>my_db</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_database'>database</span><span class='period'>.</span><span class='id identifier rubyid_create!'>create!</span>
<span class='id identifier rubyid_database'>database</span><span class='period'>.</span><span class='id identifier rubyid_drop!'>drop!</span>
</code></pre>

<h2 id="label-Creating+tables">Creating tables</h2>

<p>Once you obtained a <code>Database</code> object, you can define a table schema using <code>Egis</code> DSL</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_schema'>schema</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Egis.html" title="Egis (module)">Egis</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Egis/TableSchema.html" title="Egis::TableSchema (class)">TableSchema</a></span></span><span class='period'>.</span><span class='id identifier rubyid_define'><span class='object_link'><a href="Egis/TableSchema.html#define-class_method" title="Egis::TableSchema.define (method)">define</a></span></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_column'>column</span> <span class='symbol'>:id</span><span class='comma'>,</span> <span class='symbol'>:int</span>
  <span class='id identifier rubyid_column'>column</span> <span class='symbol'>:message</span><span class='comma'>,</span> <span class='symbol'>:string</span>

  <span class='id identifier rubyid_partition'>partition</span> <span class='symbol'>:country</span><span class='comma'>,</span> <span class='symbol'>:string</span>
  <span class='id identifier rubyid_partition'>partition</span> <span class='symbol'>:type</span><span class='comma'>,</span> <span class='symbol'>:int</span>
<span class='kw'>end</span>
</code></pre>

<p>and use <code>table</code> method to create a <code>Table</code> object.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># by default Egis assumes that the data is in TSV format
</span><span class='id identifier rubyid_table'>table</span> <span class='op'>=</span> <span class='id identifier rubyid_database'>database</span><span class='period'>.</span><span class='id identifier rubyid_table'>table</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>my_table</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_schema'>schema</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>s3://my-s3-bucket/table-data-location</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>

<span class='comment'># you can pass `format` option to change it (available options: tsv, csv, orc)
</span><span class='id identifier rubyid_table'>table</span> <span class='op'>=</span> <span class='id identifier rubyid_database'>database</span><span class='period'>.</span><span class='id identifier rubyid_table'>table</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>my_table</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_schema'>schema</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>s3://my-s3-bucket/table-data-location</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>format:</span> <span class='symbol'>:orc</span><span class='rparen'>)</span>

<span class='id identifier rubyid_table'>table</span><span class='period'>.</span><span class='id identifier rubyid_create!'>create!</span> <span class='comment'># create table in Athena
</span><span class='id identifier rubyid_table'>table</span><span class='period'>.</span><span class='id identifier rubyid_create'>create</span>  <span class='comment'># create table in Athena, ignoring if it already exists
</span></code></pre>

<h2 id="label-Loading+partitions">Loading partitions</h2>

<p>If the table is partitioned, you need to load the partitions first</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># ask Athena to scan S3 location looking for partitions
</span><span class='id identifier rubyid_table'>table</span><span class='period'>.</span><span class='id identifier rubyid_discover_partitions'>discover_partitions</span>

<span class='comment'># add partition value combinations manually (this method is much faster with large number of partitions)
</span><span class='id identifier rubyid_table'>table</span><span class='period'>.</span><span class='id identifier rubyid_add_partitions!'>add_partitions!</span><span class='lparen'>(</span><span class='label'>country:</span> <span class='qwords_beg'>%w[</span><span class='tstring_content'>us</span><span class='words_sep'> </span><span class='tstring_content'>mx</span><span class='tstring_end'>]</span></span><span class='comma'>,</span> <span class='label'>type:</span> <span class='lbracket'>[</span><span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='rbracket'>]</span><span class='rparen'>)</span>
</code></pre>

<h2 id="label-Executing+queries">Executing queries</h2>

<p>Having proper databases and tables setup, you can execute a query</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># by default Egis executes queries asynchronously and returns query ID
</span><span class='id identifier rubyid_status'>status</span> <span class='op'>=</span> <span class='id identifier rubyid_database'>database</span><span class='period'>.</span><span class='id identifier rubyid_execute_query'>execute_query</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SELECT * FROM my_table ORDER BY id;</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>

<span class='comment'># you need to check query status using query_status method which returns Egis::QueryStatus object
</span><span class='id identifier rubyid_status'>status</span> <span class='op'>=</span> <span class='id identifier rubyid_database'>database</span><span class='period'>.</span><span class='id identifier rubyid_query_status'>query_status</span><span class='lparen'>(</span><span class='id identifier rubyid_status'>status</span><span class='period'>.</span><span class='id identifier rubyid_id'>id</span><span class='rparen'>)</span>
<span class='kw'>return</span> <span class='id identifier rubyid_status'>status</span><span class='period'>.</span><span class='id identifier rubyid_output_location'>output_location</span> <span class='kw'>if</span> <span class='id identifier rubyid_status'>status</span><span class='period'>.</span><span class='id identifier rubyid_finished?'>finished?</span>
</code></pre>

<p>Query ran this way will be executed within the database&#39;s context. You can also execute a query outside of the database context by calling analogous methods on the <code>Client</code> class.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_client'>client</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Egis.html" title="Egis (module)">Egis</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Egis/Client.html" title="Egis::Client (class)">Client</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="Egis/Client.html#initialize-instance_method" title="Egis::Client#initialize (method)">new</a></span></span>
<span class='id identifier rubyid_status'>status</span> <span class='op'>=</span> <span class='id identifier rubyid_client'>client</span><span class='period'>.</span><span class='id identifier rubyid_execute_query'>execute_query</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SHOW DATABASES;</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_database'>database</span><span class='period'>.</span><span class='id identifier rubyid_query_status'>query_status</span><span class='lparen'>(</span><span class='id identifier rubyid_status'>status</span><span class='period'>.</span><span class='id identifier rubyid_id'>id</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_finished?'>finished?</span>
</code></pre>

<h2 id="label-Getting+query+results">Getting query results</h2>

<p>If the query has finished running, or you used the <code>async: false</code> option, you can easily fetch the result:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_status'>status</span> <span class='op'>=</span> <span class='id identifier rubyid_client'>client</span><span class='period'>.</span><span class='id identifier rubyid_execute_query'>execute_query</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SELECT id, name, email FROM USERS;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>async:</span> <span class='kw'>false</span><span class='rparen'>)</span>
<span class='id identifier rubyid_users'>users</span> <span class='op'>=</span> <span class='id identifier rubyid_status'>status</span><span class='period'>.</span><span class='id identifier rubyid_fetch_result'>fetch_result</span><span class='lparen'>(</span><span class='label'>schema:</span> <span class='lbracket'>[</span><span class='symbol'>:int</span><span class='comma'>,</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='symbol'>:string</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='comment'># schema is optional
</span></code></pre>

<h2 id="label-Query+execution+options">Query execution options</h2>

<p>Both <code>Client</code>&#39;s and <code>Database</code>&#39;s <code>execute_query</code> methods allow more parameters to configure their behavior: - <code>work_group</code> - override default work group - <code>database</code> - run query in the context of specific database - <code>output_location</code> - S3 location URL pointing to the directory Athena should produce output to</p>

<h2 id="label-Synchronous+query+execution">Synchronous query execution</h2>

<p>If your query is fast, or you simply prefer the program execution to wait for query results <code>Egis</code> allows you to do that as well</p>

<pre class="code ruby"><code class="ruby"># you can pass `async` param to block the execution until the query finishes
# with this option, Egis automatically polls Athena API wating for query to finish
result = database.execute_query(&#39;SELECT * FROM my_table ORDER BY id;&#39;, async: false)

# it uses exponential backoff which you can configure as well
Egis.configure do |config|
  # attempt is an API call number, starting from 1
  # defaults to: -&gt;(attempt) { 1.5**attempt - 1 }
  config.query_status_backoff = -&gt;(attempt) { ... }
end
</code></pre>

<h2 id="label-Ignoring+existing+entities">Ignoring existing entities</h2>

<p>Database&#39;s <code>create</code>, <code>drop</code>, <code>create_table</code> and <code>add_partitions</code> methods have two versions, with and without a bang (<code>!</code>). Bang versions are not permissive. For example <code>Database.create!</code> will fail when the database already exists, whereas <code>Database.create</code> will simply ignore it and do nothing.</p>

<h2 id="label-Testing">Testing</h2>

<p><code>Egis</code> provides tooling to write automated integration tests. You can wrap you tests in special testing closure that executes <code>Egis</code> queries in a virtual testing environment. Here&#39;s a RSpec usage example:</p>

<pre class="code ruby"><code class="ruby">require &#39;egis/testing&#39; # require testing module to enable additional testing capabilities

# set your testing S3 bucket
Egis.configure do |config|
  config.testing_s3_bucket = &#39;testing-bucket&#39;
end

# wrap you tests with a &quot;testing&quot; block
RSpec.configure do |c|
  # every table and database created within this block is mapped to a &quot;virtual&quot; table space in your testing S3 bucket
  c.around(:each) do |example|
    Egis.testing do
      example.run
    end
  end
end

RSpec.describe MyAthenaQuery do
  subject { described_class.run }

  let(:table) { ... } # define your databases and tables as you would define them in the code

  before do
    table.upload_data([[&#39;Column 1&#39;, Time.utc(2020), 3]]) # you can use Table.upload_data to upload test data to S3
  end

  it do
      # Table.download_data lets you load table contents to memory after executing tested code
      expect(table.download_data).to eq([[&#39;Column 1&#39;, Time.utc(2020), 3]])
  end
end
</code></pre>

<p><strong>Notice</strong>: <code>Egis</code> handles separation between virtual testing namespaces. It also cleans Athena databases at the and of testing block. But you are responsible for removing S3 files generated by tests. We highly recommend using S3 lifecycle policies to do that automatically.</p>
</div></div>

      <div id="footer">
  Generated on Mon May 18 20:05:48 2020 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.25 (ruby-2.7.1).
</div>

    </div>
  </body>
</html>